3.2.4 高阶函数的其他应用
1.currying  函数柯里化
  currying又称为部分求值。一个currying函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，
  刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正求值的时候，之前传入的所有参数将会被一次性用于求值。
  
var currying = function(fn) {
    var args = [];
    
    return function() {
        if (arguments.length === 0) {
            return fn.apply(args, arguments);
        }else {
            [].push.apply(args, arguments);
            return arguments.callee
        }
    }
}

2.uncurrying

实现方式1
Function.prototype.uncurrying = function() {
    var self = this;
    return function() {
        var obj = Array.prototype.shift.call(arguments);
        return self.apply(obj, arguments);
    }
}
实现方式2
Function.prototype.uncurrying = function() {
    var self = this;
    return function() {
        return Function.prototype.call.apply(seft, arguments);
    }
}

3. 函数节流
（1）函数被频繁调用的场景
    * window.onresize 事件
    * mousemove 事件
    * 上传进度
（2）函数节流的原理
共同问题是函数的出发频率太高

（3）函数节流的代码实现
throttle函数的原理：将即将要执行的函数用setTimeout延迟一段时间执行。如果这次延迟执行还没有完成，
则忽略接下来调用该函数的请求。throttle函数接受两个参数，第一个参数为需要被延迟执行的函数，第二个函数为延迟执行的时间。

function trottle (fn, interval) {
    var _self = fn;
    var timer;
    var firstTime = true;

    return function() {
        var args = arguments;
        var _me = this;
        if (firstTime) {
            _self.apply(_me, args);
            firstTime = false;
        }
        // 如果定时器还在，说明上次的延迟操作还没有结束
        if (timer) {
            return false;
        }

        timer = setTimeout(function() {
            clearTimeout(timer);
            timer = null;
            _self.apply(_me, args);
        }, interval || 500);
    }
}

window.onresize = trottle(function() {
    console.log(1)
}, 500);
